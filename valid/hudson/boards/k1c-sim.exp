# Copyright (C) 2010 Kalray, SA

load_generic_config "sim"

# No multilib flags needed by default.
process_multilib_options ""

set_board_info sim "k1-mppa"
set_board_info sim,options "--bootcluster=node0 --timeout=1000000000 --no-gdb-attach --dcache-no-check --"
set_board_info is_simulator 1

# The compiler used to build for this board. This has *nothing* to do
# with what compiler is tested if we're testing gcc.
set_board_info compiler 	"[find_gcc]"

# Used by a few gcc.c-torture testcases to delimit how large the stack can
# be.
set_board_info gcc,stack_size 524288

# No support for signals.
set_board_info gdb,nosignals 1

# More time is needed to compile PlumHall tests
set_board_info gcc,timeout 800

global profiling_available_saved
set profiling_available_saved 0

global TOOL_OPTIONS
set TOOL_OPTIONS "-march=k1c -DSIGNAL_SUPPRESS"
#set TOOL_OPTIONS "-march=k1b -DSIGNAL_SUPPRESS -tirex"

#let's overload that...
proc transform { name } {
        return "k1-$name" 
}

proc remote_spawn { dest commandline args } {
# Override remote_spawn, because sometimes the SIGHUP from the closed expect channel
# might come in and kill the process before it has a chance to exit cleanly.
# Dejagnu does pass -ignore SIGHUP in local_exec for that exact reason, but here we are
# in remote_spawn      

    global board_info

    if ![is_remote $dest] {
        if [info exists board_info($dest,fileid)] {
            unset board_info($dest,fileid)
        }
        verbose "remote_spawn is local" 3
        if [board_info $dest exists name] {
            set dest [board_info $dest name]
        }

        verbose "spawning command $commandline"

        if { [llength $args] > 0 } {
            if { [lindex $args 0] == "readonly" } {
                set result [catch { open "| ${commandline} |& cat" "r" } id]
                if { $result != 0 } {
                    return -1
                }
            } else {
                set result [catch {open "| ${commandline}" "w"} id]
                if { $result != 0 } {
                    return -1
                }
            }
            set result [catch "spawn -leaveopen $id" result2]
            if { $result == 0 && $result2 == 0} {
                verbose "setting board_info($dest,fileid) to $spawn_id" 3
                set board_info($dest,fileid) $spawn_id
                set board_info($dest,fileid_origid) $id
                return $spawn_id
            } else {
                # This shouldn't happen.
                global errorInfo
                if [info exists errorInfo] {
                    set foo $errorInfo
                } else {
                    set foo ""
                }
                verbose "spawn -open $id failed, $result $result2, $foo"
                catch "close $id"
                return -1
            }
        } else {
	    verbose "IGNORING SIGHUP" 1

            set result [catch "spawn -ignore SIGHUP $commandline" pid]
            if { $result == 0 } {
                verbose "setting board_info($dest,fileid) to $spawn_id" 3
                set board_info($dest,fileid) $spawn_id
                return $spawn_id
            } else {
                verbose -log "spawn of $commandline failed"
                return -1
            }
        }
    }

    # Seems to me there should be a cleaner way to do this.
    if { "$args" == "" } {
        return [call_remote "" spawn "$dest" "$commandline"]
    } else {
        return [call_remote "" spawn "$dest" "$commandline" $args]
    }


}
